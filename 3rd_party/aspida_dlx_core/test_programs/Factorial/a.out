; Linked by DLX-LD.
; MemSize 12288
; Data size: 116
; Text size: 736
; Stack size: 8192
.text 0x0000
.data 0x0800
;;; Ethan L. Miller, 1999.  Released to the public domain
;;;
;;; Most of the traps are called in files from libtraps.
.text
.align 2
.proc ___init_LF0
	lhi	r29,0x0000
	addui	r29,r0,0x0FFC
	add	r30,r29,r0
	jal	_main
	nop
.endproc ___init_LF0


.align 2
.proc _exit
.global _exit
_exit:
	trap	0x300
	jr	r31
	nop
.endproc _exit

; for the benefit of gcc.

.align 2
.proc ___main
.global ___main
___main:
	jr	r31
	nop
.endproc ___main

; Trap Handler

.align 7
___trap_LF0:
	nop
	nop
	nop
	beqz	r0,___trap_LF0
	nop
	nop
	nop
; Compiled by GCC

.align 2
.proc _fac
.global _fac
_fac:
;  Function 'fac'; 0 bytes of locals, 2 regs to save.
	sw	-4(r29),r30; push fp
	add	r30,r0,r29; fp = sp
	sw	-8(r29),r31; push ret addr
	subui	r29,r29,16; alloc local storage
	sw	0(r29),r2
	sw	4(r29),r3
	lw	r3,(r30)
	sgti	r1,r3,1
	beqz	r1,L2_LF1
	nop; not filled.
	addi	r29,r29,-8
	addi	r1,r3,-1
	sw	(r29),r1
	jal	_fac
	nop; not filled.
	addi	r29,r29,8
	add	r2,r0,r1
	addi	r29,r29,-8
	sw	(r29),r3
	sw	4(r29),r2
	jal	_mult
	nop; delay slot nop
	addi	r29,r29,8
	add	r2,r0,r1
	j	L3_LF1
	nop; not filled.
L2_LF1:
	addi	r2,r0,1
L3_LF1:
	add	r1,r0,r2
	lw	r2,0(r29)
	lw	r3,4(r29)
	lw	r31,-8(r30)
	add	r29,r0,r30
	lw	r30,-4(r30)
	jr	r31
	nop
.endproc _fac
.align 2
.proc _main
.global _main
_main:
;  Function 'main'; 0 bytes of locals, 0 regs to save.
	sw	-4(r29),r30; push fp
	add	r30,r0,r29; fp = sp
	sw	-8(r29),r31; push ret addr
	subui	r29,r29,8; alloc local storage
	jal	___main
	nop; not filled.
	addi	r2,r0,0
	lhi	r5,((_results_int)>>16)&0xffff
	addui	r5,r5,(_results_int)&0xffff
	lhi	r4,((_results_short)>>16)&0xffff
	addui	r4,r4,(_results_short)&0xffff
	lhi	r3,((_results_char)>>16)&0xffff
	addui	r3,r3,(_results_char)&0xffff
L8_LF1:
	addi	r29,r29,-8
	sw	(r29),r2
	jal	_fac
	nop; not filled.
	sb	(r3),r1
	andi	r1,r1,0x00ff
	sh	(r4),r1
	slli	r1,r1,16
	srai	r1,r1,16
	sw	(r5),r1
	addi	r29,r29,8
	addi	r5,r5,4
	addi	r4,r4,2
	addi	r3,r3,1
	addi	r2,r2,1
	slei	r1,r2,5
	bnez	r1,L8_LF1
	nop; not filled.
	lhi	r1,((_final)>>16)&0xffff
	addui	r1,r1,(_final)&0xffff
	addi	r31,r1,48
	lhi	r6,((_results_char)>>16)&0xffff
	addui	r6,r6,(_results_char)&0xffff
	addi	r5,r1,24
	lhi	r4,((_results_short)>>16)&0xffff
	addui	r4,r4,(_results_short)&0xffff
	add	r2,r0,r1
	lhi	r3,((_results_int)>>16)&0xffff
	addui	r3,r3,(_results_int)&0xffff
	addi	r7,r2,68
L13_LF1:
	lw	r8,(r3)
	sw	(r2),r8
	lh	r1,(r4)
	sw	(r5),r1
	lbu	r1,(r6)
	sw	(r31),r1
	addi	r31,r31,4
	addi	r6,r6,1
	addi	r5,r5,4
	addi	r4,r4,2
	addi	r2,r2,4
	addi	r3,r3,4
	sle	r1,r31,r7
	bnez	r1,L13_LF1
	nop; not filled.
	jal	_exit
	nop
.endproc _main
.data
.align 2
.global _results_int
_results_int:
.space 24
.align 1
.global _results_short
_results_short:
.space 12
.global _results_char
_results_char:
.space 6
.align 2
.global _final
_final:
.space 72




;---------------------------------------------------------------------------------------
;
; MULT --- MULT --- MULT --- MULT --- MULT --- MULT
;
; Signed 32 x 32 -> 32 bit Multiply routine
; 
; This version takes the two operands from the stack (dividend and divisor in the
; order) and returns in r1 the result according to the standard C call
; c = mult(a,b);
; register r29 is assumed to be the stack pointer
; all other used registers are saved into the stack and restored on the return
;
; For internal debugging purposes this is the internal use of the registers
;  r5 multiplicand
;  r6 multiplier
;  r7 result
;  r1 counter
;  r2 mask
;  r3 scratch
;		
;  r29 Stack pointer
;  r30 Frame Pointer
;  r31 Return address
;
; F.Gregoretti January 7th 2004
; 
.text

.align 2

.proc _mult

.global _mult

_mult:; initial operations
	sw	-4(r29),r30; save frame pointer
	add	r30,r29,r0; new fp = sp
	subui	r29,r29,#28; allocate space for saving registers  in the stack
	sw	0(r29),r2; save r2
	sw	4(r29),r3; save r3
	sw	8(r29),r5; save r5
	sw	12(r29),r6; save r6
	sw	16(r29),r7; save r7
	sw	16(r29),r8; save r7				;
	lw	r5,0(r30); load multiplicand from the stack
	lw	r6,4(r30); load multiplier from the stack
	add	r8,r0,r0; Clear r8
	sgt	r3,r0,r5; test dividend  r3 = 0 if positive)
	beqz	r3,m0_pos1_LF2

	nop

	addi	r8,r8,#1; sets flag
	sub	r5,r0,r5; changes sign to the multiplicand
m0_pos1_LF2:

	sgt	r3,r0,r6; test divisor
	beqz	r3,m0_pos2_LF2

	nop; delay slot
	subi	r8,r8,#1; sets flag 
	sub	r6,r0,r6; changes sign to the multiplier
m0_pos2_LF2:; flag = 0 if dividend and divisor are both pos or neg				;
	addi	r1,r0,#32; set counter r1 to 32
	addi	r2,r0,#1; create mask on LSB with r2
	add	r7,r0,r0

m0_loop_LF2:

	add	r3,r0,r6; moves r6 into r3
	and	r3,r3,r2; r3 has the value of the LSB of r6
	beqz	r3,m0_noadd_LF2; bit is 0
	nop

	add	r7,r7,r5; bit is 1 - addition
m0_noadd_LF2:

	srli	r6,r6,#1; shift right the multiplier to test next bit
	slli	r5,r5,#1; shift left the multiplicand to multiply by 2
	subi	r1,r1,#1; decrement the counter
	bnez	r1,m0_loop_LF2

	nop

	beqz	r8,m0_endmul_LF2; test for sign of the result
	nop

	sub	r7,r0,r7

m0_endmul_LF2:

	add	r1,r0,r7; put result into r1
	lw	r7,16(r29); restore r7
	lw	r6,12(r29); restore r6
	lw	r5,8(r29); restore r5
	lw	r3,4(r29); restore r3
	lw	r2,0(r29); restore r2
	add	r29,r30,r0; restore stack pointer
	lw	r30,-4(r29); restore old frame pointer
	jr	r31; return from subroutine
	nop

	nop

	nop



.text
.global _etext
_etext:
.align 3
.data
.global _edata
_edata:
